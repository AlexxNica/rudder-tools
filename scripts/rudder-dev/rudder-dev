#!/usr/bin/env python

"""
Rudder development tool.

You need a configuration file, if you don't have one, the tool will create one for you at first run.

Usage:
    rudder-dev -h|--help
    rudder-dev [-f|--force] clone <repository_name> [--fork]
    rudder-dev [-f|--force] pull [<branch>]
    rudder-dev [-f|--force] branch <ticket_id> [--base=<ticket_id>]
    rudder-dev [-f|--force] technique <version> <comment>
    rudder-dev [-f|--force] subtask [<next_branch>] [--title=<new_title>] [--bug]
    rudder-dev [-f|--force] wip
    rudder-dev [-f|--force] commit [<trigraph> [<PR_comment>]]
    rudder-dev [-f|--force] amend [<PR_comment>]
    rudder-dev [-f|--force] rebase [--base=<ticket_id>] [<PR_comment>]
    rudder-dev [-f|--force] retarget [<target_version>]
    rudder-dev [-f|--force] takeover <ticket_id>
    rudder-dev [-f|--force] revert <ticket_id> [--retarget]
    rudder-dev [-f|--force] merge all [-s <strategy>] [-a|--automatic]
    rudder-dev [-f|--force] merge <first_branch/ticket_id> [-s <strategy>] [-a|--automatic]
    rudder-dev [-f|--force] merge <first_branch/ticket_id> <next_branch> [-s <strategy>] [-a|--automatic]
    rudder-dev [-f|--force] merge [-s <strategy>] [-a|--automatic]
    rudder-dev [-f|--force] find <command>
    rudder-dev [-f|--force] cleanup [--more] [-n|--dry-run]
    rudder-dev [-f|--force] update
    rudder-dev [-f|--force] <smart_arg> [<PR_message>] [--base=<ticket_id>]

SMART
    <smart_arg> is a shortcut for other commands
    - if it is a number > 100, it is guessed to be a ticket_id -> branch
    - if it is a x.y or master, it is guessed to be a branch -> pull
    - if it is a caps TLA, it is guessed to be a trigraph -> commit

CLONE
    Call it when you want to work on a new repository.
    - fork the repository from Normation if --fork is given
    - clone it
    - setup both remote repository in git
    ex: rudder-dev clone rudder-techniques
    
PULL
    Call it to make sure you are on a branch and up to date.
    - create the branch with remote tracking if it doesn't exist
    - checkout the branch if specified
    - update the current branch
    ex: rudder-dev pull 3.0
    ex: rudder-dev pull master

BRANCH
    Call it before working on a bug.
    - if the branch already exist, just checkout it
    - find and check the ticket from redmine
    - create a branch with the proper name in your repository
    - set the ticket status to "in progress"
    - if --base is given, use the PR from the base ticket as the origin branch
    - --base can also be a local branch name
    ex: rudder-dev branch 1234
    ex: rudder-dev branch '#1234' --base 1233

TECHNIQUE
    Call it after branching and before working on a new technique version.
    You must be in the technique directory containing all technique versions.
    - create a new version of a technique based on the last known version
    - add the comment to the changelog
    - create a commit for this new version
    ex: cd techniques/applications/apacheServer
        rudder-dev technique 4.0 "Add a new option"

SUBTASK
    Call it after commiting a patch and you want a different patch on the next version.
    Or if you want to extend a feature from one branch in a new branch.
    Or if just discovered a bug in a PR that was just merdged.
    For example, after a ncf v0.x patch you want to amend it in ncf v1.
    - create a new ticket that is the child copy of the current one (set its tracker to Bug if --bug)
    - set the new ticket version to next_version (but not with --bug)
    - replace the issue's title if needed (if the new title starts with '+', extend the existing title)
    - call rudder-dev branch on the new ticket with a base branch from the old ticket
    - suggest modifications for logs in the modified files (ncf v1 specific)
    ex: rudder-dev sub <version>

WIP
    Commit a work in progress to keep it for later.
    Later call to rudder-dev commit will merge wip with the final commit.
    - commit with a sample "Work in progress" message
    - push on matching branch on own repository
    ex: rudder-dev wip

COMMIT
    Call it after working on a branch.
    - fork the repository if it has not yet been forked
    - commit current work (no -a, you need to git add)
    - push the branch to your github repository
    - make a pull-request to Normation's repository
    - update the coresponding bug with those informations
    ex: rudder-dev commit BPF "@reviewer please tell me it's good"
    ex: rudder-dev commit

AMEND
    Call it after you made a change to a branch with a PR.
    - commit current work amending last commit (no -a, you need to git add)
    - push the branch to your github repository
    - add a comment to the PR to signal the change
    ex: rudder-dev amend "@reviewer pr updated"

REBASE
    Call it when a PR is not mergeable anymore.
    - interactive rebase on NRM branch
    - if rebase has worked, push to OWN
    - add a comment to the PR to signal the change
    - if --base is given, use the PR from the base ticket as the origin branch
    - --base can also be a local branch name
    ex: rudder-dev rebase "@reviewer pr updated"
    ex: rudder-dev rebase --base 1234

RETARGET
    Call it when you started on the wrong version, to change the base branch.
    - if a version is provided, update the ticket with it
    - if the ticket's version has changed, continue
    - rebase to ticket's NRM branch
    - close current PR
    - create new PR
    - update ticket
    ex: rudder-dev retarget

TAKEOVER
    Call it when someone else has started a work you want to continue.
    - if the ticket has no pull-request, abandon
    - checkout upstream branch into local repository
    - rename it if needed
    - update the ticket's status
    ex: rudder-dev takeover 1234

REVERT
    Call it when a PR has been merged but you don't want it.
    - If the ticket has no pull-request, abandon
    - If retarget, ensure we have everything merged
    - Find merge commit of pull request
    - Revert pull request merge commit
    - if retarget, merge it to next branch with ours strategy (keep changes in next branch)
    ex: rudder-dev revert 1234

MERGE
    Call it when you want to merge different branches (needs commit rights)
    or when you want to merge a Pull-Request.
    "merge all" and "merge <first_branch>" are only valid within Rudder versioned repositories.
    Use --automatic to automatically validate merge comment.
    - detect the ticket id from current branch if there is no parameter 
    - checkout an pull last version or the PR branch for a given ticket
    - checkout an pull new version
    - merge both
    - push result to Normation's repository
    - if we are merging a ticket or 'all', continue merging to next version
    If the merge fails, please make adjustments, commit and rerun this command.
    ex: rudder-dev merge 3.0 master
    ex: rudder-dev merge all
    ex: rudder-dev merge 1234

FIND
    Call it to search thing within active branches.
    - for each branch version
    - checkout branch
    - run command
    - find when it returns 0
    ex: rudder-dev find 'grep bugfix path/file.cf'

CLEANUP
    Call it when your local repository becomes messy.
    - for each branch in local repository
    - if ticket is closed
    - if branch's commit are pushed upstream
    - remove local and remote branch
    With --more, include more branch that are not strictly clean, such as 
      closed tickets that have un unmerged commits are asked to the user.
    ex: git cleanup

UPDATE
    Call it when you want the last version of rudder-dev.
    - download last version from https://www.rudder-project.org/tools/rudder-dev
    - replace current rudder-dev with it
    - use sudo if needed

"""

from __future__ import print_function
import sys
import os
import re
import string
import webbrowser
import locale
import time
import json
from distutils.version import LooseVersion
from pprint import pprint
from subprocess import Popen,PIPE
from tempfile import NamedTemporaryFile

import requests # apt-get install python-requests || pip install requests
import docopt # apt-get install python-docopt || pip install docopt

try:
  import configparser
  config = configparser.ConfigParser()
except ImportError:
  import ConfigParser
  config = ConfigParser.ConfigParser()


## GLOBAL VARIABLES
RUDDER_DEV_ORIGIN = "https://www.rudder-project.org/tools/rudder-dev"
WARN_FOR_UPDATE_AFTER = 15 # days

LIFECYCLES = [ { "name": "rudder",
                 "detection": r'^\*?\s+remotes/{}/branches/rudder/(.*)',
                 "format": "branches/rudder/{}",
                 "redmine_version": [ (r'master|.*~alpha\d+', r'master'), (r'(\d+\.\w\d*).*', r'\1') ],
               },
               { "name": "ncf",
                 "detection": r'^\*?\s+remotes/{}/v(\d\..*)',
                 "format": "v{}",
                 "redmine_version": [ (r'master', r'master'), (r'(\d+\.\w\d*).*', r'\1') ],
               },
               { "name" : "master_only",
                 "detection": r'(.*)',
                 "format": "master",
                 "redmine_version": [ (r'.*', r'master') ],
               },
             ]
CONFIG_FILE = "~/.rudder-dev"
CACHE_FILE = "~/.rudder-dev.cache"
HUB_CONFIG_FILE = "~/.config/hub"
REDMINE_ALT_API_URL = "https://redmine.normation.com"
REDMINE_API_URL = "https://www.rudder-project.org/redmine"
REDMINE_API_LIMIT = 100
REDMINE_CLOSED_STATUSES = [5, 6, 16, 11] # 5=Released, 6=rejected, 16=resolved, 11=Pending release
REDMINE_META_TRACKERS = [3]
ACCESS_ROLE_LIST = [ 3, 4, 5, 6, 7, 8, 9, 11 ] # 7=Product owner, 3=Scrum master, 8=Lead developer, 4=Developer, 5=Reporter, 11=Release manager, 6=Consultant, 9=Integrator

# Keeping old version for reference
#TRACKER_NAME_MAPPING = { 'Bug': 'bug', 'Implementation (development)': 'dev', 'Implementation (integration)': 'int' }
TRACKER_NAME_MAPPING = { 'Bug': 'bug', 'User story': 'ust', 'Architecture': 'arch', 'Change': 'chg', 'Problem': 'pbm', 'Incident': 'inc' }
PENDING_TR_CODE = 3
IN_PROGRESS_CODE = 9
CUSTOM_FIELD_PR = 3
ALT_CUSTOM_FIELD_PR = 1
BUG_TACKER_ID = 1
PR_VALIDATED_LABEL = "Ready for merge"

# Default error template
ERROR_TPL = "\033[1;31m{}\033[0m"


###
### Classes to put in a separate library
###

# Redmine related

class Issue:
  """Class to hold informations about a single issue"""
  def __init__(self, name, must_be_open=True):
    """name is a string like: 1234 or i1234"""
    self.name = name
    self.must_be_open = must_be_open
    self.info = None
    if name.startswith('#'):
      name = name [1:]
    is_internal = re.match(r'i(\d+)', name)
    if is_internal:
      self.id = int(is_internal.group(1))
      self.token = REDMINE_ALT_TOKEN
      self.api_url = REDMINE_ALT_API_URL
      self.custom_field_pr = ALT_CUSTOM_FIELD_PR
      self.internal = True
    else:
      self.id = int(name)
      self.token = REDMINE_TOKEN
      self.api_url = REDMINE_API_URL
      self.custom_field_pr = CUSTOM_FIELD_PR
      self.internal = False

  def __getitem__(self, key):
    """Make Issue behave like a dict"""
    if self.info is None:
      self.get_info()
    if key not in self.info:
      return None
    return self.info[key]

  def get_info(self):
    """Get issue informations from redmine"""
    # Find issue in redmine
    print("Looking for Redmine ticket #" + self.name + "... ", end=' ')
    sys.stdout.flush() # to display previous unfinished line
    issues_req = requests.get(self.api_url + "/issues/" + str(self.id) + ".json?include=journals", 
                              headers = {'X-Redmine-API-Key': self.token, 'Content-Type': 'application/json' })
    issue = issues_req.json()['issue'] if issues_req.status_code == requests.codes.ok else None
    if not issue:
      print("Not found!")
      logfail("***** ERROR: ticket not found. Exiting.")
      if not force:
        exit(2)
    else:
      print("Done")
    
    # Check ticket type
    if issue['tracker'] in REDMINE_META_TRACKERS:
      print("This is a question ticket! You cannot make a pull request on this ticket.")
      logfail("***** ERROR: This is a question ticket. Exiting.")
      if not force:
        exit(2)
  
    # Check ticket status
    if self.must_be_open and issue['status']['id'] in REDMINE_CLOSED_STATUSES:
      print("This ticket is closed! You cannot make a pull request on this ticket.")
      logfail("***** ERROR: Closed ticket. Exiting.")
      if not force:
        exit(2)
  
    if 'fixed_version' not in issue:
      print("This ticket has no target version! I can't make a branch against its repository.")
      logfail("***** ERROR: Missing target version. Exiting.")
      if not force:
        exit(2)
  
    self.data = issue

    # Get ticket elements
    info = {}
    info['type'] = issue['tracker']['name']
    info['name'] = issue['subject']
    info['version'] = get_version(issue)
    info['project_id'] = issue['project']['id']
    info['tracker_id'] = issue['tracker']['id']
    info['priority_id'] = issue['priority']['id']
    info['subject'] = issue['subject']
    info['description'] = issue['description']
    info['private'] = 'is_private' in issue and issue['is_private']
    if 'category' in issue:
      info['category_id'] = issue['category']['id']
    if 'is_private' in issue:
      info['is_private'] = issue['is_private']
    if 'custom_fields' in issue:
      for field in issue['custom_fields']:
        if field['id'] == self.custom_field_pr and 'value' in field:
          info['pr'] = field['value']
  
    # Get ticket's last assignment besides me
    my_id = get_redmine_uid()
    if 'journals' in issue:
      for journal in issue['journals']:
        if 'details' in journal:
          for detail in journal['details']:
            if detail['name'] == 'assigned_to_id' and 'old_value' in detail:
              if int(detail['old_value']) != my_id:
                info['last_assignee'] = int(detail['old_value'])
  
    self.info = info
    return info

def issue_from_branch(branch):
  """Create issue object from given branch"""
  match = re.match(r'[A-Za-z]+_(i?\d+)/.*', branch)
  if match:
    return Issue(match.group(1))
  else:
    logfail("***** ERROR: This is not a ticket branch: " + branch)
    exit(4)

# Github related
class PR:
  """A Pull Request"""
  def __init__(self, url):
    self.url = url

  def is_labeled(self, label):
    """Tell if the pull request is labeled with label"""
    url = "https://api.github.com/repos/Normation/{repo}/issues/{pr_id}/labels"
    label_list = github_request(url, None, self.url)
    labels = [x['name'] for x in label_list]
    return label in labels


###
###  Internal functions
### 

# Run a command in a shell like a script would do
# And inform the user of its execution
def shell(command, comment=None, keep_output=False, fail_exit=True):
  if comment is not None:
    print(comment)
    print(" $ " + command)
  if keep_output:
    process = Popen(command, stdout=PIPE, shell=True)
    output, error = process.communicate()
    retcode = process.poll()
  else: # keep tty management and thus colors
    process = Popen(command, shell=True)
    retcode = process.wait()
    output = None
  if fail_exit and retcode != 0:
    if comment is None:
      print(command)
    logfail("*** COMMAND ERROR " + str(retcode))
    if not force:
      exit(1)
  if keep_output:
    if sys.version_info[0] != 2:
      output = output.decode("utf-8")
  if not fail_exit:
    return (retcode, output)
  else:
    return output


def logfail(message):
  print(ERROR_TPL.format(message))

def parse_ticket_id(ticket_id):
  global REDMINE_TOKEN, REDMINE_API_URL, CUSTOM_FIELD_PR
  if ticket_id.startswith('#'):
    ticket_id = ticket_id[1:]
  internal = False
  match = re.match(r'i(\d+)', ticket_id)
  if match:
    ticket_id = match.group(1)
    REDMINE_TOKEN = REDMINE_ALT_TOKEN
    REDMINE_API_URL = REDMINE_ALT_API_URL
    CUSTOM_FIELD_PR = ALT_CUSTOM_FIELD_PR
    internal = True
  return (ticket_id, internal)


# Get the version included in a ticket
def get_version(ticket, error_fail=True):
  if 'fixed_version' not in ticket:
    if error_fail:
      logfail("***** BUG: Can't extract version from #" + str(ticket['id']))
      exit(2)
    else:
      return None
  detector = get_lifecycle()['redmine_version']
  for k,v in detector:
    if re.match(k, ticket['fixed_version']['name']):
      return re.sub(k, v, ticket['fixed_version']['name'])
  if error_fail:
    logfail("***** BUG: Can't extract version from " + ticket['fixed_version']['name'])
    exit(2)
  else:
    return None
 

# Get informations about a ticket from redmine
# Deprecated, use Issue()['field']
def get_ticket_info(ticket_id, internal=False, must_be_open=True):
  # Find ticket in redmine
  print("Looking for Redmine ticket #" + str(ticket_id) + "... ", end=' ')
  sys.stdout.flush() # to display previous unfinished line
  tickets_req = requests.get(REDMINE_API_URL + "/issues/" + str(ticket_id) + ".json?include=journals", 
                             headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' })
  ticket = tickets_req.json()['issue'] if tickets_req.status_code == requests.codes.ok else None
  if not ticket:
    print("Not found!")
    logfail("***** ERROR: ticket not found. Exiting.")
    if not force:
      exit(2)
  else:
    print("Done")
  
  # Check ticket type
  if ticket['tracker'] in REDMINE_META_TRACKERS:
    print("This is a question ticket! You cannot make a pull request on this ticket.")
    logfail("***** ERROR: This is a question ticket. Exiting.")
    if not force:
      exit(2)

  # Check ticket status
  if must_be_open and ticket['status']['id'] in REDMINE_CLOSED_STATUSES:
    print("This ticket is closed! You cannot make a pull request on this ticket.")
    logfail("***** ERROR: Closed ticket. Exiting.")
    if not force:
      exit(2)

  if 'fixed_version' not in ticket:
    print("This ticket has no target version! I can't make a branch against its repository.")
    logfail("***** ERROR: Missing target version. Exiting.")
    if not force:
      exit(2)

  # TODO check assignment ? project ?

  # Get ticket elements
  info = {}
  info['id'] = ticket_id
  info['type'] = ticket['tracker']['name']
  info['name'] = ticket['subject']
  info['version'] = get_version(ticket)
  info['project_id'] = ticket['project']['id']
  info['internal'] = internal
  info['tracker_id'] = ticket['tracker']['id']
  info['priority_id'] = ticket['priority']['id']
  info['subject'] = ticket['subject']
  info['description'] = ticket['description']
  info['private'] = 'is_private' in ticket and ticket['is_private']
  if 'category' in ticket:
    info['category_id'] = ticket['category']['id']
  if 'is_private' in ticket:
    info['is_private'] = ticket['is_private']
  if 'custom_fields' in ticket:
    for field in ticket['custom_fields']:
      if field['id'] == CUSTOM_FIELD_PR and 'value' in field:
        info['pr'] = field['value']

  # Get ticket's last assignment besides me
  my_id = get_redmine_uid()
  if 'journals' in ticket:
    for journal in ticket['journals']:
      if 'details' in journal:
        for detail in journal['details']:
          if detail['name'] == 'assigned_to_id' and 'old_value' in detail:
            if int(detail['old_value']) != my_id:
              info['last_assignee'] = int(detail['old_value'])

  return info


# clone a ticket in redmine making the new one a child of the original
def clone_ticket(info, version, new_title, bug=False):
  new_info = {}
  for i in ('project_id', 'tracker_id', 'priority_id', 'subject', 'description', 'category_id', 'fixed_version_id', 'is_private'):
    if i in info:
      new_info[i] = info[i]
  new_info['parent_issue_id'] = info['id']
  if bug:
    new_info['tracker_id'] = BUG_TACKER_ID
    new_info['description'] = "There was a bug in the resolution of #" + str(info['id'])
  if new_title is not None:
    if new_title.startswith('+'):
      new_info['subject'] += new_title.replace('+', ' ', 1)
    else:
      new_info['subject'] = new_title
  all_versions_id = get_versions()[1]
  new_info['fixed_version_id'] = all_versions_id[version]
  ticket_json = json.dumps({ 'issue': new_info })
  ret = requests.post(REDMINE_API_URL + "/issues.json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' }, data=ticket_json )
  if ret.status_code != 201:
    logfail("Ticket clone error: " + ret.reason)
    if not force:
      exit(3)
  return ret.json()['issue']


# Return true if the current user can modify an issue in the given project
REDMINE_CAN_MODIFY=None
def can_modify_issues(project_id):
  global REDMINE_CAN_MODIFY
  if REDMINE_CAN_MODIFY is not None:
    return REDMINE_CAN_MODIFY
  data = requests.get(REDMINE_API_URL + "/users/current.json?include=memberships", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
  user = data.json()
  for membership in user['user']['memberships']:
    if membership['project']['id'] == project_id:
      for role in membership['roles']:
        if role['id'] in ACCESS_ROLE_LIST:
          REDMINE_CAN_MODIFY = True
          return True
  REDMINE_CAN_MODIFY = False
  return False


# Change a ticket version to the closest version available
def update_ticket_version(info, version):
  if not can_modify_issues(info['project_id']):
    logfail("Cannot change ticket version since you are not a developer, you should change it manualy before calling retarget")
    exit(13)

  # list all versions
  versions = requests.get(REDMINE_API_URL + "/projects/" + str(info['project_id']) + "/versions.json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
  # keep versions that match and that are still open
  valid_versions = [ v for v in versions.json()['versions'] if v['status'] == 'open' and v['name'].startswith(version) ]
  # there should only only, but in doubt keep the last one
  final_version = valid_versions[-1]

  # set the version
  ticket_info = { 'issue': { 'fixed_version_id': final_version['id'] } }
  url = REDMINE_API_URL + "/issues/" + str(info['id']) + ".json"
  ticket_json = json.dumps(ticket_info)
  ret = requests.put(url, headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' }, data=ticket_json )
  if ret.status_code != 200:
    logfail("Ticket Update error: " + ret.reason)
    print(ret.text)
    if not force:
      exit(3)
  info['version'] = get_version( { 'fixed_version': final_version } )


# Change ticket state to technical review
def ticket_to_TR(info, user_id=None, pr_url=None, message=None):
  # Create note content
  note = None
  if pr_url is not None:
    note = "PR " + pr_url
  if message is not None:
    if note is None:
      note = message
    else:
      note += "\n" + message

  if can_modify_issues(info['project_id']):
    # fill ticket data with developer available content
    ticket_info = { 
            'issue': {
                'status_id': PENDING_TR_CODE,
            }
        }
    if user_id is not None:
      ticket_info['issue']['assigned_to_id'] = user_id
    if note is not None:
      ticket_info['issue']['notes'] = note
    if pr_url is not None:
      ticket_info['issue']['custom_fields'] = [ { 'id': CUSTOM_FIELD_PR, 'value': pr_url } ]

  else:
    # just append the note to ticket
    if note is None:
      return
    else:
      ticket_info = {
              'issue': {
                'notes': note,
              }
          }
  
  # call the api
  url = REDMINE_API_URL + "/issues/" + str(info['id']) + ".json"
  ticket_json = json.dumps(ticket_info)
  ret = requests.put(url, headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' }, data=ticket_json )
  if ret.status_code != 200:
    logfail("Ticket Update error: " + ret.reason)
    print(ret.text)
    if not force:
      exit(3)


# change the ticket state to In progress
def ticket_to_in_progress(info, message=None):
  # set ticket status to "in progress"
  if REDMINE_TOKEN is not None:
    if can_modify_issues(info['project_id']):
      print("Changing status of ticket #" + str(info['id']) + " to \"In progress\"")
      user_id = get_redmine_uid()
      ticket_info = {
              'issue': {
                  'status_id': IN_PROGRESS_CODE,
                  'assigned_to_id': user_id,
              }
      }
      if message is not None:
        ticket_info['issue']['notes'] = message
      url = REDMINE_API_URL + "/issues/" + str(info['id']) + ".json"
      ticket_json = json.dumps(ticket_info)
      ret = requests.put(url, headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' }, data=ticket_json )
      if ret.status_code != 200:
        logfail("Ticket Update error: " + ret.reason)
        print(ret.text)
        if not force:
          exit(3)
    else:
      print("You should update the ticket status here " + REDMINE_API_URL + "/issues/" + str(info['id']))


# get current redmine user
def get_redmine_uid():
  user = requests.get(REDMINE_API_URL + "/users/current.json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
  return user.json()['user']['id']


# update normation user list cache and return updated user list
def update_nrm_users(project_id):
  # read existing cahe if there is one
  filename = os.path.expanduser(CACHE_FILE)
  if os.path.isfile(filename):
    with open(filename) as fd:
      users = json.load(fd)
  else:
    users = { }
  if REDMINE_API_URL not in users:
    users[REDMINE_API_URL] = {}
  # just update it otherwise we would have only project specific data in it
  user_list = requests.get(REDMINE_API_URL + "/projects/" + str(project_id) + "/memberships.json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
  for user in user_list.json()['memberships']:
    id = user['user']['id']
    user_data = requests.get(REDMINE_API_URL + "/users/" + str(id) + ".json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
    user_detail = user_data.json()['user']
    if 'mail' in user_detail and user_detail['mail'].endswith("normation.com"):
      trigraph = (user_detail['firstname'][0] + user_detail['lastname'][:2]).upper()
      users[REDMINE_API_URL][trigraph] = { 'id': id, 'trigraph': trigraph, 'firstname':user_detail['firstname'] , 'lastname':user_detail['lastname'] }
  with open(filename, "w") as fd:
    json.dump(users, fd)
  return users

# get users ad trigraph for normation users
def get_nrm_users(project_id):
  users = {}
  filename = os.path.expanduser(CACHE_FILE)
  if not os.path.isfile(filename):
    users = update_nrm_users(project_id)
  else:
    with open(filename) as fd:
      users = json.load(fd)
    if not REDMINE_API_URL in users:
      users = update_nrm_users(project_id)
  return users[REDMINE_API_URL]

# Ask for a user using its trigraph
def ask_username(project_id, trigraph):
  # List Normation users and index by trigraph
  user_ids = get_nrm_users(project_id)

  # Ask for trigraph of user until found
  if trigraph is not None:
    trigraph = trigraph.upper()
  while trigraph not in user_ids:
    print("Assign to ?")
    for user in user_ids.values():
      print("  " + user['trigraph'] + ". " + user['firstname'] + " " + user['lastname'])
    print("  NON. No one")
    print("Enter trigraph (or 'r' to reload user list, 'n' for ): ", end='')
    sys.stdout.flush() # to display previous unfinished line
    trigraph = sys.stdin.readline().strip().upper()
    if trigraph == 'R':
      update_nrm_users(project_id)
    if trigraph == 'NON':
      return None
  return user_ids[trigraph]['id']


# Find a ticket id in a branch name
def ticket_from_branch(branch, must_be_open=True):
  match = re.match(r'[A-Za-z]+_(i?\d+)/.*', branch)
  if match:
    (ticket_id, internal) = parse_ticket_id(match.group(1))
    return get_ticket_info(ticket_id, internal, must_be_open)
  else:
    logfail("***** ERROR: This is not a ticket branch: " + branch)
    exit(4)


current_lifecycle = None
# Get the current lifecycle
def get_lifecycle():
  global current_lifecycle
  if current_lifecycle is not None:
    return current_lifecycle
  # Update branches so get new branches from UPSTREA
  shell("git fetch --force " + UPSTREAM_REPOSITORY, "Fetching upstream " + UPSTREAM_REPOSITORY)
  lines = os.popen("git branch --no-color --list -a").readlines()
  for lifecycle in LIFECYCLES:
    for line in lines:
      if re.match(lifecycle["detection"].format(UPSTREAM_REPOSITORY), line):
        current_lifecycle = lifecycle
        return current_lifecycle
  return current_lifecycle


version_list = None
version_dict = None
# get the version list for a given project
def get_versions():
  global version_list, version_dict
  if version_list is not None:
    return (version_list, version_dict)

  # list all versions in git
  lifecycle = get_lifecycle()
  git_version_list = []
  for line in os.popen("git branch --no-color --list -a"):
    m = re.match(lifecycle["detection"].format(UPSTREAM_REPOSITORY), line)
    if m:
      git_version_list.append(m.group(1))

  # list all versions using redmine
  versions = requests.get(REDMINE_API_URL + "/projects/" + lifecycle['name'] + "/versions.json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
  redmine_version_list = []
  version_dict = {}
  for version in versions.json()['versions']:
    if version['status'] != 'open':
      continue
    detector = lifecycle['redmine_version']
    v = None
    for k,val in detector:
      if re.match(k, version['name']):
        v = re.sub(k, val, version['name'])
        break
    if v in git_version_list or v == 'master':
      redmine_version_list.append(v)
      version_dict[v] = version['id']
  
  # add master, keep unique name and sort
  version_list = list(set(redmine_version_list))
  version_list.sort(key=LooseVersion)

  return (version_list, version_dict)


# get the version after old
def get_next_version(old):
  all_versions = get_versions()[0]
  new = None
  for idx, version in enumerate(all_versions):
    if old == version:
      if idx < len(all_versions)-1:
        new = all_versions[idx+1]
  if new is None:
    logfail("Don't know how to find the version after " + old)
    exit(9)
  return new


# Get branch name from version
def branch_from_version(version):
  # detect lifecycle and base ne name on it
  lifecycle = get_lifecycle()
  if version == "master":
    return version
  else:
    return lifecycle['format'].format(version)


# Calculate branch name from a ticket
def branch_from_ticket(info):
  branchified_ticket_name = re.sub("__+", "_", re.sub("[^" + string.ascii_letters + string.digits + "]", "_", info['name'].strip().lower())).strip("_")
  if info['internal']:
    id = 'i' + str(info['id'])
  else:
    id = str(info['id'])
  if info['private']:
    branch_name = TRACKER_NAME_MAPPING[info['type']] + "_" + id + "/_"
  else:
    branch_name = TRACKER_NAME_MAPPING[info['type']] + "_" + id + "/" + branchified_ticket_name
  return branch_name


# Find an existing branch for a ticket id
def branch_from_ticket_id(ticket_id, internal):
  for line in os.popen("git branch --no-color --list"):
    if internal:
      ticket = 'i'+str(ticket_id)
    else:
      ticket = str(ticket_id)
    match = re.search(r'^\*?\s*(\w+_' + ticket + r'/.*?)\n', line)
    if match:
      return match.group(1)
  return None


# Read rudder configuration from ~/.rudder-dev or create a template if none found
def read_configuration():
  global UPSTREAM_REPOSITORY, OWN_REPOSITORY, GITHUB_TOKEN, REDMINE_TOKEN, REDMINE_ALT_TOKEN, ERROR_TPL

  # Detect missing configuration
  if not os.path.isfile(os.path.expanduser(CONFIG_FILE)):
    with open(os.path.expanduser(CONFIG_FILE), 'a') as cfile:
      cfile.write("""[default]
## Uncomment and set your own values
## Your prefered name for Normation upstream repository on your local git (NRM, origin, ...)
#nrm_upstream = NRM
## Your prefered name for personal upstream repository on your local git (ABC, origin, ...)
#own_upstream =
## If github cli is installed, rudder-dev will read hub's configuration file to get the user's github token
## Otherwise, yo manage your tokens, click here https://github.com/settings/tokens (click "Generate new token")
# github_token = 
## Redmine personal access token, get yours here http://www.rudder-project.org/redmine/my/account (under "API access key")
#redmine_token = 
## For Normation people only
#redmine_alt_token = 
## For colorblind or dumb terminal change ansicode here (ref: http://pueblo.sourceforge.net/doc/manual/ansi_color_codes.html)
## Do no forget to add keeep {} to have the text content
#error_tpl = \\033[1;31m{}\\033[0m
""")
    print(CONFIG_FILE + " doesn't exist !")
    logfail("I made a sample one, please fill it")
    exit(5)
  
  # Read configuration
  config.read(os.path.expanduser(CONFIG_FILE))
  UPSTREAM_REPOSITORY = get_config("nrm_upstream", "No 'nrm_upstream' entry in " + CONFIG_FILE)
  OWN_REPOSITORY = get_config("own_upstream", "No 'own_upstream' entry in " + CONFIG_FILE)
  GITHUB_TOKEN = get_config("github_token", None)
  REDMINE_TOKEN = get_config("redmine_token", None)
  REDMINE_ALT_TOKEN = get_config("redmine_alt_token", None)
  ERROR_TPL = get_config("error_tpl", None)
  if ERROR_TPL is None:
    ERROR_TPL = "\\033[1;31m{}\\033[0m"
  # replace \\Oxx characters by their octal equivalent
  ERROR_TPL = re.sub(r'(\\0\d+)', lambda x: chr(int(x.group(0)[1:],8)), ERROR_TPL)


# Get a configuration item from current configuration file
def get_config(item, error):
  try:
    return config.get("default", item)
  except:
    if error is None:
      return None
    else:
      logfail(error)
      exit(5)


# Get github user as used by the hub command
def get_github_user():
  user_data=github_request("https://api.github.com/user", None)
  if 'login' in user_data:
    return user_data['login']
  else:
    logfail("Github user not found")
    exit(6)


# Get github token as used by the hub command
def get_github_token(can_fail=False):
  if GITHUB_TOKEN is not None:
    return GITHUB_TOKEN
  if os.path.isfile(os.path.expanduser(HUB_CONFIG_FILE)):
    with open(os.path.expanduser(HUB_CONFIG_FILE)) as f:
      for line in f:
        match = re.search(r'oauth_token: (\w+)', line)
        if match:
          return match.group(1)
  if can_fail:
    return None
  else:
    logfail("Github user not found")
    exit(6)


# Find remote repository name from current directory
def remote_repo():
  value = shell("git remote -v", keep_output=True).strip()
  match = re.search(r'git@github.com:Normation/(.*?).git', value)
  if match:
    return match.group(1)
  logfail("Can't find remote repository")
  exit(10)


# query github
def github_request(api_url, comment, pr_url=None, post_data=None):
  pr_id = None
  if pr_url is not None:
    # Validate PR url
    match = re.match(r'^http.*/(\d+)(/files|/commits)?$', pr_url)
    if match:
      pr_id = match.group(1)
    else:
      print("Can't find pull-request ID, you should warn the reviewer that you updated the pull-request")
      return False

  # get connection info
  token = get_github_token()
  repo = remote_repo()
  url = api_url.format(repo=repo, pr_id=pr_id)

  # Say what we are doing
  if comment is not None:
    print(comment)
    print(" $ api-call [...] " + url)

  # make query
  if post_data is not None:
    if sys.version_info[0] == 2:
      post_data = post_data.encode('utf-8')
    ret = requests.post(url, headers = {'Authorization': 'token ' + token, 'Content-Type': 'application/json' }, data=post_data)
  else:
    ret = requests.get(url, headers = {'Authorization': 'token ' + token, 'Content-Type': 'application/json' })

  # process output
  if ret.status_code < 200 or ret.status_code >= 300:
    logfail("Github query error " + ret.reason)
    print(ret.text)
    if not force:
      exit(12)

  # return result
  return ret.json()
 

# create a new PR
def create_pr(master_branch, info, message):
  url = "https://api.github.com/repos/Normation/{repo}/pulls"
  user = get_github_user()
  body = REDMINE_API_URL + "/issues/" + str(info['id'])
  if message is not None:
    body += "\n\n" + message + "\n"

  if info['private']:
    title = ''
  else:
    title = info['name'].replace("\"", "\\\"")
  pr = '{ "title": ' + json.dumps('Fixes #' + str(info['id']) + ": " + title) + ','
  pr += ' "body": ' + json.dumps(body) + ','
  pr += ' "head": "' + user + ':' + current_branch + '",'
  pr += ' "base": "' + master_branch + '" }'
  result = github_request(url, "Creating PR ...", pr_url=None, post_data=pr)
  return result['html_url']


# add a message to a given pull-request on github
def update_pr(pr_url, info, comment):
  message = info
  if comment is not None:
    message += "\\n" + comment
  issue = '{ "body": "' + message + '" }'
  url = "https://api.github.com/repos/Normation/{repo}/issues/{pr_id}/comments"
  github_request(url, "Updating PR ...", pr_url, issue)


# close a given pull-request on github
def close_pr(pr_url, comment):
  # Add comment on the closing reason
  issue = '{ "body": "' + comment + '" }'
  url = "https://api.github.com/repos/Normation/{repo}/issues/{pr_id}/comments"
  github_request(url, "Commenting PR ...", pr_url, issue)
  
  # close the PR
  issue = '{ "state": "closed" }'
  url = "https://api.github.com/repos/Normation/{repo}/pulls/{pr_id}"
  github_request(url, "Closing PR ...", pr_url, issue)


# get PR upstream branch
def get_pr_upstream(pr_url):
  url = "https://api.github.com/repos/Normation/{repo}/pulls/{pr_id}"
  pr = github_request(url, None, pr_url)
  return pr['base']['ref']
  
# get PR source informations
def get_pr_source(pr_url):
  url = "https://api.github.com/repos/Normation/{repo}/pulls/{pr_id}"
  pr = github_request(url, None, pr_url)
  return (pr['head']['repo']['ssh_url'], pr['head']['ref'])

# get PR merge commit
def get_pr_merge_commit(pr_url):
  url = "https://api.github.com/repos/Normation/{repo}/issues/{pr_id}/events"
  pr_events = github_request(url, None, pr_url)
  pr_merged = [ pr for pr in pr_events if pr["event"] == "merged" ]
  if len(pr_merged) != 1: 
    logfail("Can't find merge commit for pull request")
    exit(12)
  return pr_merged[0]['commit_id']


# Commit and push, if needed squash WIP and force push
def commit_push(branch, message, force_amend=False):
  # Fork if needed
  if github_fork():
    # github fork is asynchronous but pretty fast, this should be sufficient
    time.sleep(2)

  (code, wip) = shell("git log --grep \"^Work in progress\" HEAD^..", keep_output=True, fail_exit=False)
  if code == 0:
    wip = wip.strip()
  else:
    wip = ''
  commit_cmd = "git commit"
  if message != '':
    commit_cmd += " -m \"" + message + "\""
  if force_amend or wip != "":
    commit_cmd += " --amend --no-edit"
  shell(commit_cmd, "Commiting")

  # Should we check the need for rebasing before pushing ?

  push_cmd = "git push " + OWN_REPOSITORY + " " + branch
  if force_amend or wip != "":
    push_cmd += " --force"
  shell(push_cmd, "Pushing to " + OWN_REPOSITORY + " ... ")


# insert a line in a file after a regex has matched
def insert_line(filename, regex, text):
  content=[]
  with open(filename, "r+") as fd:
    for line in fd:
      content.append(line)
      if re.match(regex, line):
        content.append(text)
    fd.seek(0)
    fd.truncate()
    fd.writelines(content)


# fetch a branch from a PR given in a ticket
def fetch_branch_from_ticket(ticket):
  # extract ticket info
  (ticket_id, internal) = parse_ticket_id(ticket)
  info = get_ticket_info(ticket_id, internal)
  if 'pr' not in info or info['pr'] == '':
    logfail("There is no PR in this ticket " + ticket)
    exit(15)

  # look for PR
  (repo, remote_branch) = get_pr_source(info['pr'])

  # fetch remote branch
  branch_name = branch_from_ticket(info)
  shell("git fetch --update-head-ok " + repo + " " + remote_branch + ":" + branch_name, "Fetching branch from remote " + repo)

  return branch_name


def github_fork():
  # we don't need to fork if the remote is known
  remotes = shell("git remote show", keep_output=True).strip()
  if re.search('^'+OWN_REPOSITORY+"$", remotes, flags=re.MULTILINE):
    return False

  # fork the report if not already forked
  remote_url = ""
  user = get_github_user()
  remote = remote_repo()
  fork_needed = shell("git ls-remote git://github.com/" + user + "/" + remote + ".git HEAD > /dev/null 2>/dev/null; echo $?", keep_output=True).strip()
  if fork_needed != "0":
    github_request("https://api.github.com/repos/Normation/{repo}/forks", "Forking repository ...", pr_url=None, post_data="")

  # Add the remote repository to the local list
  shell("git remote add " + OWN_REPOSITORY + " git@github.com:" + user + "/" + remote + ".git", "Adding own remote repository")

  # Tell if we forked or not
  return fork_needed != "0"


# Find if there is work in progress and stash it
stashed=False
def stash():
  global stashed
  # count number of change
  change_count = shell("git status --porcelain --untracked-files=no | wc -l", keep_output=True).strip()
  if change_count != "0":
    # stash them
    shell("git stash save --keep-index", "Stashing current work")
    stashed = True


# Find if there is stashed work and unstash it
unstashed=False
def unstash():
  global unstashed

  # only unstash things we have stashed
  if not stashed:
    return

  # get current branch (the global variable may not be accurate in flight)
  this_branch = shell("git rev-parse --abbrev-ref HEAD", keep_output=True).strip()

  # do not unstash if we are on an origin branch since you should not work directly on them
  remote_count = shell("git ls-remote -h " + UPSTREAM_REPOSITORY + " " + this_branch + " | wc -l", keep_output=True).strip()
  if remote_count != "0":
    return

  # list available stashes
  stash_output = shell("git stash list", keep_output=True)
  for line in stash_output.splitlines():
    # parse
    match = re.match(r'^(stash@{.*?}): WIP on (.*?):.*', line)
    if match:
      # match with current branch
      if match.group(2) == this_branch:
        #unstash it
        shell("git stash pop --index '" + match.group(1) + "'" , "Unstashing previous work")
        unstashed=True


# Tell the user if some stash command happened
def stash_info():
  if stashed:
    print("Some work in progress has been found, " + ERROR_TPL.format("I stashed it") + " before running the commands, to retrieve it use git stash pop")
  if unstashed:
    print("Previous work in progress has been found in the stash, " + ERROR_TPL.format("I unstashed it") + ", to hide it again, use git stash save")


###
### MAIN methods 
###   branch, commit, rebase, clone, pull
###

# Create a branch from a ticket id
def create_branch(ticket, base=None):
  global current_branch
  (ticket_id, internal) = parse_ticket_id(ticket)

  existing_branch = branch_from_ticket_id(ticket_id, internal)
  if existing_branch is not None:
    shell("git checkout " + existing_branch, "Found existing branch, checkouting " + existing_branch)
    return

  # get ticket info
  info = get_ticket_info(ticket_id, internal)
  print("* Found " + info['type'] + " #" + str(info['id']) + ": " + info['name'])
  print("* Target: " + info['version'])
  print("* URL: " + REDMINE_API_URL + "/issues/" + str(info['id']))

  # manage the original branch
  if base is not None:
    if re.match(r'^.\d*$', base):
      # fetch base branch
      branch_name = fetch_branch_from_ticket(base)
    else:
      branch_name = base
    # checkout the new branch
    shell("git checkout " + branch_name, "Checkouting the base branch " + branch_name)
  else:
    # Look for release branch and ckeckout its last version
    pull(info['version'])

  # Create the branch
  current_branch = branch_from_ticket(info)
  shell("git checkout -b " + current_branch, "Creating branch " + current_branch)

  # Set ticket's status
  ticket_to_in_progress(info)

  print("")
  print("# Now you can edit files")
  print("# When you're ready, add them with git add")
  print("# Then type:")
  print(os.path.basename(sys.argv[0]) + " commit")
  print("")


# new version, changelog, commit
def technique(version, message):
  # check current directory
  cwd = os.getcwd()
  match = re.match(r'(.*)/techniques/.*', cwd)
  if not re.match(r'.*/techniques/.*', cwd):
    logfail("***** ERROR: You must be in a technique directory")
    exit(7)
  basedir = match.group(1)
  script = basedir + '/scripts/technique-files'
  if not os.path.isfile(script):
    logfail("***** ERROR: You must be in rudder-technique repository")
    exit(7)
  last_version = shell(script + " -ld .", keep_output=True).strip()
  match = re.match(r'\./(\d+\.\d+)', last_version)
  if not match:
    logfail("***** ERROR: There must be at least one version of the technique in the current directory")
    exit(7)
  last_version = match.group(1)

  # check next version
  match = re.match(r'\d+\.\d+', version)
  if not match:
    logfail("***** ERROR: Version must be of the form x.y")
    exit(7)
  
  # check branch info
  info = ticket_from_branch(current_branch)

  # new version
  shell("cp -r " + last_version + " " + version, "Creating the version " + version)

  # Deprecate old version
  insert_line(last_version + "/metadata.xml",
              r'\s*<TECHNIQUE name=',
              "  <DEPRECATED>This technique version has been superseded by a new version. It will no longer be available in the next stable version of Rudder. Please upgrade to the latest version.</DEPRECATED>\n")
  shell("git add " + last_version + "/metadata.xml", "Adding deprecated info to old version")

  # changelog
  l = locale.setlocale(locale.LC_ALL, 'C')
  date = time.strftime("%c")
  locale.setlocale(locale.LC_ALL, l)
  user = shell("git config --get user.name", keep_output=True).strip()
  mail = shell("git config --get user.email", keep_output=True).strip()
  changelog = " -- " + user + " <" + mail + "> " + date + "\n"
  changelog += "  * Version " + version + "\n"
  changelog += "  ** " + message + "\n"
  with open(version + "/changelog", "a") as fd:
    fd.write(changelog)

  # commit
  shell("git add " + version, "Adding next version")
  technique = os.path.basename(cwd)
  commit_cmd = "git commit -m \"Refs #" + str(info['id']) + ": Creation of " + technique + " version " + version + " from " + last_version + "\""
  shell(commit_cmd, "Commiting")


# clone ticket, change version, branch, helper
def subtask(next_version, new_title, bug=False):
  # make a clone child ticket with next version
  info = ticket_from_branch(current_branch, False)
  if next_version is None:
    if bug:
      next_version = info['version']
    else:
      next_version = get_next_version(info['version'])
  print("Next version will be " + str(next_version))
  print("Cloning ticket #" + str(info['id']))
  ticket = clone_ticket(info, next_version, new_title, bug)
  print(" > ticket #" + str(ticket['id']) + " created " + REDMINE_API_URL + "/issues/" + str(ticket['id']))

  # test merge status
  pull(next_version)
  logs = shell("git log --no-merges '--grep=Fixes #" + str(info['id']) + "' --oneline", "Looking for ticket commit in " + next_version, keep_output=True)

  # rudder-dev branch
  if info['internal']:
    ticket_id = 'i'+str(ticket['id'])
  else:
    ticket_id = str(ticket['id'])

  # if branch has been merged, just do a regular branch
  if len(logs) != 0:
    create_branch(ticket_id)
  # if branch has not been merged, base the ticket on the original
  else:
    create_branch(ticket_id, current_branch)
  
    # rebase to next_version
    next_branch = branch_from_version(next_version)
    shell("git rebase -i " + next_branch, "Rebasing to " + next_version)

 
# commit, push
def wip():
  # must be on a working branch
  match = re.match(r'[A-Za-z]+_(i?)(\d+)/.*', current_branch)
  if not match:
    logfail("***** ERROR: This is not a ticket branch: " + branch)
    exit(4)
  commit_push(current_branch, "Work in progress")


# Commit, push, create pull-request, update ticket
def commit(trigraph=None, message=None):
  info = ticket_from_branch(current_branch)
  master_branch = branch_from_version(info['version'])

  # commit and push
  if info['private']:
    title = ''
  else:
    title = info['name'].replace("\"", "\\\"")
  commit_push(current_branch, "Fixes #" + str(info['id']) + ": " + title)

  # create PR
  pr_url = create_pr(master_branch, info, message)
  print("PR URL: " + pr_url)

  # update ticket
  if REDMINE_TOKEN is not None and pr_url is not None:
    if can_modify_issues(info['project_id']):
      user = ask_username(info['project_id'], trigraph)
    else:
      user = None
    print("Updating ticket #" + str(info['id']))
    ticket_to_TR(info, user, pr_url, message)
    print("Ticket updated: " + REDMINE_API_URL + "/issues/" + info['id'])
  else:
    print("You can now update the ticket here " + REDMINE_API_URL + "/issues/" + info['id'])


# amend commit, push -f, comment PR
def amend(comment=None):
  info = ticket_from_branch(current_branch)
  
  # commit over last commit and push
  if info['private']:
    title = ''
  else:
    title = info['name'].replace("\"", "\\\"")
  commit_push(current_branch, "Fixes #" + str(info['id']) + ": " + title, True)

  # reassign ticket
  if 'last_assignee' in info:
    ticket_to_TR(info, info['last_assignee'])

  # Message on PR if there is one
  if 'pr' in info and info['pr'] != '':
    update_pr(info['pr'], "Commit modified", comment)
    print("Done, you can see the PR here: " + info['pr']) 
  else:
    print("No PR found.")


# rebase, push -f, comment PR
def rebase(comment=None, base=None):
  info = ticket_from_branch(current_branch)

  # fetch before rebasing
  if base is not None:
    if re.match(r'^.\d*$', base):
      # base branch from ticket id
      branch_name = fetch_branch_from_ticket(base)
    else:
      # base branch from branch name
      branch_name = base
  else:
    # base branch from upstream repository
    shell("git fetch --force " + UPSTREAM_REPOSITORY, "Fetching upstream " + UPSTREAM_REPOSITORY)
    origin_branch = branch_from_version(info['version'])
    branch_name = UPSTREAM_REPOSITORY + "/" + origin_branch

  # First rebase without commits from source branch
  # This is necessary because we may have modified the original commit and force pushed it
  with NamedTemporaryFile(delete=False) as tmpscript:
    script = """#!/bin/sh
perl -i -ne "print unless s/^pick \w+ Fixes #(?!%(ticket)s)//" "$1"
""" % { "ticket": info['id']}
    tmpscript.write(script.encode("utf-8"))
    tmpscript.close()
    os.system("chmod +x " + tmpscript.name)
    # If it fails, let the interactive rebase try to fix it
    shell("EDITOR=" + tmpscript.name + " git rebase -i " + branch_name, "First rebase to remove parent commits", fail_exit=False)
    os.unlink(tmpscript.name)


  # Then interactive rebase
  shell("git rebase -i " + branch_name, "Rebasing")

  # if OK: continue
  shell("git push --force " + OWN_REPOSITORY + " " + current_branch, "Pushing rebased branch")

  # reassign ticket
  if 'last_assignee' in info:
    ticket_to_TR(info, info['last_assignee'])

  # Message on PR if there is one
  if 'pr' in info and info['pr'] != '':
    update_pr(info['pr'], "PR rebased", comment)
    print("Done, you can see the PR here: " + info['pr'])
  else:
    print("No PR found.")


# close PR, rebase, push -f, create PR, update ticket
def retarget(version=None):
  info = ticket_from_branch(current_branch)

  # update ticket if required
  if version is not None:
    print("Changing target version in the ticket to " + version)
    update_ticket_version(info, version)
    print("New version " + info['version'])

  ticket_branch = branch_from_version(info['version'])

  if 'pr' in info and info['pr'] != '':
    upstream_branch = get_pr_upstream(info['pr'])
    if ticket_branch == upstream_branch:
      print("Ticket branch and PR branch match (" + upstream_branch + "), no need to retarget!")
      return

  # fetch before rebasing
  shell("git fetch " + UPSTREAM_REPOSITORY, "Fetching upstream " + UPSTREAM_REPOSITORY)

  # interactive rebase
  shell("git rebase -i " + UPSTREAM_REPOSITORY + "/" + ticket_branch, "Rebasing")

  if 'pr' in info and info['pr'] != '':
    # if OK: continue
    shell("git push --force " + OWN_REPOSITORY + " " + current_branch, "Pushing rebased branch")

    # create new PR 
    pr_url = create_pr(ticket_branch, info, "Replacing previous PR: " +  info['pr'])

    # close old PR
    close_pr(info['pr'], "PR replaced by " + pr_url)

    # update ticket
    user = None
    if 'last_assignee' in info:
      user = info['last_assignee']
    ticket_to_TR(info, user, pr_url)
    print("New PR URL: " + pr_url)


# ckeckout version, pull
def pull(version=None):
  global current_branch
  if version is not None:
    branch = branch_from_version(version)

    # branch if needed
    branch_status = shell("git branch --list " + branch, keep_output=True).strip()
    if branch_status == "":
      shell("git fetch " + UPSTREAM_REPOSITORY, "Local branch doesn't exist, fetching from " + UPSTREAM_REPOSITORY)
      remote_branch_status = os.popen("git branch --no-color --list --remote " + UPSTREAM_REPOSITORY + "/" + branch)
      if remote_branch_status == "":
        logfail("No such branch on " + UPSTREAM_REPOSITORY + ": " + branch + ", Aborting ...")
        exit(8)
      shell("git branch --track " + branch + " " + UPSTREAM_REPOSITORY + "/" + branch, "Creating local branch")

    # checkout if needed
    if branch != current_branch:
      shell("git checkout " + branch, "Checkouting " + branch)
    current_branch = branch

  # Pull
  branch_detail = shell("git rev-parse --abbrev-ref --symbolic-full-name @{u}", keep_output=True).strip()
  if re.match(UPSTREAM_REPOSITORY + '/.*', branch_detail):
    shell("git pull --ff-only", "Pulling on " + branch_detail)
  else:
    logfail("Your branch is not based on the same " + UPSTREAM_REPOSITORY + " branch")
    exit(8)


# clone from NRM, fork, add OWN, set-upstream
def clone(name, fork=False):
  token = get_github_token(can_fail=True)
  if token is not None:
    url = "git@github.com:Normation/"
  else:
    url = "https://github.com/Normation/"
  shell("git clone --origin " + UPSTREAM_REPOSITORY + " " + url + name + ".git", "Cloning Normation repository")
  if fork:
    os.chdir(name)
    github_fork()


# takevover a ticket with an existing PR
def takeover(ticket):
  global current_branch
  (ticket_id, internal) = parse_ticket_id(ticket)
  existing_branch = branch_from_ticket_id(ticket_id, internal)
  if existing_branch is not None:
    logfail("***** ERROR: Can't take over a ticket with a matching branch already existing in your repository")
    exit(12)

  # fetch base branch
  current_branch = fetch_branch_from_ticket(ticket)

  # checkout the new branch
  shell("git checkout " + current_branch, "Checkouting the base branch " + current_branch)

  # same workflow as work in progress (but with an existing commit)
  commit_push(current_branch, "Work in progress", True)

  # Set ticket's status
  info = get_ticket_info(ticket_id, internal)
  ticket_to_in_progress(info, "I'm taking over this ticket!")

  print("")
  print("# Now you can edit files")
  print("# When you're ready, add them with git add")
  print("# Then type:")
  print(os.path.basename(sys.argv[0]) + " commit")
  print("")


# Merge remote version
def merge_version(old, new, strategy=None, automatic=False):
  pull(old)
  branch = branch_from_version(old)
  merge_branch(branch, new, strategy, automatic, old)

# Merge remote branch
def merge_branch(old, new, strategy=None, automatic=False, name=""):
  pull(new)
  opts = ""
  if strategy is not None:
    opts = " -s " + strategy
  if automatic:
    opts += " --no-edit "
  shell("git merge " + old + opts, "Merging " + name + " into " + new)
  shell("git push " + UPSTREAM_REPOSITORY + " " + branch_from_version(new), "Pushing merged branch")


# Merge remote version automatically guessing the next one
def merge_to_next(old, strategy=None, automatic=False):
  new = get_next_version(old)
  merge_version(old, new, strategy, automatic)


# Merge all versions to next one
def merge_all(strategy=None, automatic=False):
  for version in get_versions()[0][:-1]:
    merge_to_next(version, strategy, automatic)

# Merge given issue to given branch
def merge_issue(issue_name=None, version=None, strategy=None, automatic=False):
  # get issue info
  if issue_name is None:
    issue = issue_from_branch(current_branch)
  else:
    issue = Issue(issue_name)
  
  # PR must be validated
  pr = PR(issue['pr'])
  if not pr.is_labeled(PR_VALIDATED_LABEL):
    print("This PR is not labeled '" + PR_VALIDATED_LABEL + "' You should not merge it.")
    logfail("***** ERROR: PR is not validated. Exiting.")
    if not force:
      exit(15)

  # get merge info
  pr_branch = fetch_branch_from_ticket(issue.name)
  if version is None:
    version = issue['version']
  # regular merge
  merge_branch(pr_branch, version, strategy, automatic, issue.name)
  # upmerge
  last_version = get_versions()[0][-1]
  while version != last_version:
    merge_to_next(version, strategy, automatic)
    version = get_next_version(version)

# Revert commit from ticket passed as parameter, use retarget to keep changes on next branch  
def revert(ticket, retarget = False):
  (ticket_id, internal) = parse_ticket_id(ticket)
  info = get_ticket_info(ticket_id, internal, False)

  # Find merge commit id
  if 'pr' in info and info['pr'] != '':
    commit = get_pr_merge_commit(info['pr'])
  else:
    logfail("There is no pull request linked to that issue, abort reverting")
    exit(1)

  pull(info['version'])
  # If we retarget a change, we want only this change to be reverted, so ensure we have already merged the branch correctly
  if retarget: 
    merge_to_next(info['version'])
  
  # Reverting
  shell("git revert -m1 " + commit, "Reverting issue #" + info["id"] + ":" + info["name"]+ ", commit: " + commit  )
  shell("git push " + UPSTREAM_REPOSITORY, "Updating " + UPSTREAM_REPOSITORY)

  # If we retarget that issue, merge it with ours strategy so the chnage is still present in next version 
  if retarget: 
    merge_to_next(info['version'], "ours")


# Run a command on all branches
def find(command):
  status = {}
  for branch in get_versions()[0]:
    pull(branch)
    (status[branch], x) = shell(command, "Running your command", fail_exit=False)
  print("---")
  for branch in  get_versions()[0]:
    ok = "OK" if status[branch] == 0 else "ERR"
    print("%6s: %3s (%d)" % (branch, ok, status[branch]))
  print("---")


# cleanup branches
def cleanup(more=False, dry=False):
  shell("git fetch " + UPSTREAM_REPOSITORY, "Fetching " + UPSTREAM_REPOSITORY)
  pull('master') # necessary to avoid removal errors
  branch_list = shell("git branch --no-color --no-column", keep_output=True)
  for branch in branch_list.splitlines():
    m = re.match(r'^\s*((?:bug|dev|int|impl|ust|UST)_(\d+)/.*)\s*$', branch)
    if m:
      branch=m.group(1)
      ticket_id = m.group(2)
      print("#" + ticket_id + ": ", end='')
      tickets_req = requests.get(REDMINE_API_URL + "/issues/" + str(ticket_id) + ".json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' })
      remove = False

      # guess if we should remove the branch
      if tickets_req.status_code == requests.codes.ok:
        ticket = tickets_req.json()['issue']
        # The ticket is closed -> probably
        if ticket['status']['id'] in REDMINE_CLOSED_STATUSES:
          print("ticket closed, ", end='')
          version = get_version(ticket, False)
          should_ask = False
          if version is not None:
            upstream = UPSTREAM_REPOSITORY + '/' + branch_from_version(version)
            (code, cherry_list) = shell("git cherry " + upstream + " " + branch + " 2>/dev/null", keep_output=True, fail_exit=False)
            if code == 0 and cherry_list == "":
              # Everything is merged -> YES
              print("commits merged upstream, ", end='')
              remove = True
            else:
              # Some commits mays not have been merged -> Ask the user
              print("some commits not merged upstream, ", end='')
              should_ask = True
          else:
            # Can't find upstream branch -> ask the user
            print("can't check upstream branch from ticket, ", end='')
            should_ask = True
          if more and should_ask:
            print(REDMINE_API_URL + "/issues/" + ticket_id)
            print("Do you want to remove it ? [y/N]", end='')
            sys.stdout.flush() # to display previous unfinished line
            answer = sys.stdin.readline().strip().upper()
            if answer.upper() == "Y":
              remove = True
        # The ticket is open -> NO
      
      if remove:
        print("removing: " + branch)
        if not dry:
          shell("git branch -d " + branch, "Deleting local " + branch)
          shell("git push " + OWN_REPOSITORY + " --delete " + branch, "Deleting remote " + branch)
      else:
        print("keeping: " + branch)


def update():
  my_path = os.path.abspath(__file__)
  with open(my_path, 'r') as fd:
    my_text = fd.read()

  data = requests.get(RUDDER_DEV_ORIGIN)
  if data.status_code != requests.codes.ok:
    logfail("Cannot get last version of rudder-dev sorry!")
    exit(14)
  new_text = data.text

  # No update needed
  if my_text == new_text:
    print("No update needed!")
    (code, x) = shell("touch '" + my_path + "'", "Trying touch to avoid warnings", fail_exit=False)
    if code != 0:
      shell("sudo touch '" + my_path + "'", "Trying sudo touch to avoid warnings")
    exit(0)

  # Try to update rudder-dev with our access rights
  try:
    with open(my_path, 'w') as fd:
      fd.write(new_text)
  except Exception as e:
    # Try with sudo instead
    shell("cat <<'EOF' | sudo tee '" + my_path + "' > /dev/null \n" + new_text + "\nEOF\n")

  print("rudder-dev has been updated, well done!")


def check_update():
  my_path = os.path.abspath(__file__)
  # mtime = last modification = content changed
  ctime = os.path.getmtime(my_path)
  days_ago = (time.time() - ctime) / 60 / 60 / 24
  if days_ago > WARN_FOR_UPDATE_AFTER:
    print("Your version of rudder-dev is old and probably needs an update, please run 'rudder-dev update'")
  # else everything is up to date


# Main loop
if __name__ == "__main__":
  arguments = docopt.docopt(__doc__)
  read_configuration()

  # smart argument
  smart = arguments['<smart_arg>']
  if smart:
    if re.match(r'^i?\d{2,5}$', smart):
      arguments['branch'] = True
      arguments['<ticket_id>'] = smart
    elif re.match(r'^\d\.(\d+|x)$|^master$', smart):
      arguments['pull'] = True
      arguments['<branch>'] = smart
    elif re.match(r'^[A-Z]{3}$', smart):
      arguments['commit'] = True
      arguments['<trigraph>'] = smart
    else:
      logfail("Error, unknown <smartarg> " + smart)
      exit(10)

  # Force argument is a global variables
  force = arguments['-f'] or arguments['--force']

  if not arguments['clone']: # this is the only exception
    # check repository and get common info
    (code, current_branch) = shell("git rev-parse --abbrev-ref HEAD", keep_output=True, fail_exit=False)
    current_branch = current_branch.strip()
    if code != 0:
      logfail("***** ERROR: Unable to get the current git branch name, this directory is probably not a git repository")
      exit(11)

  # check if update is needed
  check_update()

  # standard arguments
  if arguments['clone']:
    clone(arguments['<repository_name>'], arguments['--fork'])
  elif arguments['pull']:
    stash()
    pull(arguments['<branch>'])
    unstash()
    stash_info()
  elif arguments['branch']:
    stash()
    create_branch(arguments['<ticket_id>'], arguments['--base'])
    unstash()
    stash_info()
  elif arguments['technique']:
    technique(arguments['<version>'], arguments['<comment>'])
  elif arguments['subtask']:
    subtask(arguments['<next_branch>'], arguments['--title'], arguments['--bug'])
  elif arguments['wip']:
    wip()
  elif arguments['commit']:
    commit(arguments['<trigraph>'], arguments['<PR_comment>'])
  elif arguments['amend']:
    amend(arguments['<PR_comment>'])
  elif arguments['rebase']:
    rebase(arguments['<PR_comment>'], arguments['--base'])
  elif arguments['retarget']:
    retarget(arguments['<target_version>'])
  elif arguments['takeover']:
    takeover(arguments['<ticket_id>'])
  elif arguments['revert']:
    revert(arguments['<ticket_id>'], arguments['--retarget'])
  elif arguments['merge']:
    stash()
    before_merge_branch = current_branch
    if arguments['all']:
      merge_all(arguments['<strategy>'], arguments['-a'] or arguments['--automatic'])
    elif arguments['<first_branch/ticket_id>'] is None:
      merge_issue(strategy=arguments['<strategy>'], automatic=arguments['-a'] or arguments['--automatic'])
    elif arguments['<next_branch>'] is None:
      if re.match(r'^i?\d{3,}$', arguments['<first_branch/ticket_id>']): # 3+ digits -> ticket_id, otherwise it's a branch
        merge_issue(issue_name=arguments['<first_branch/ticket_id>'], strategy=arguments['<strategy>'], automatic=arguments['-a'] or arguments['--automatic'])
      else:
        merge_to_next(arguments['<first_branch/ticket_id>'], arguments['<strategy>'], arguments['-a'] or arguments['--automatic'])
    else:
      if re.match(r'^i?\d{3,}$', arguments['<first_branch/ticket_id>']): # 3+ digits -> ticket_id, otherwise it's a branch
        merge_issue(arguments['<first_branch/ticket_id>'], arguments['<next_branch>'], arguments['<strategy>'], arguments['-a'] or arguments['--automatic'])
      else:
        merge_version(arguments['<first_branch/ticket_id>'], arguments['<next_branch>'], arguments['<strategy>'], arguments['-a'] or arguments['--automatic'])
    shell("git checkout " + before_merge_branch, "Going back to the branch we were before merge")
    unstash()
  elif arguments['find']:
    find(arguments['<command>'])
  elif arguments['cleanup']:
    cleanup(arguments['--more'], arguments['-n'] or arguments['--dry-run'])
  elif arguments['update']:
    update()

